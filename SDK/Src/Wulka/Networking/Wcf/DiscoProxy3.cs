using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using NLog;
using Wulka.Core;
using Wulka.Domain;
using Wulka.Domain.Authentication;
using Wulka.Exceptions;

namespace Wulka.Networking.Wcf
{
    /// <summary>
    /// It is also no longer necessary to close the client after every call.
    /// The AutoGenerated Proxy will reuse its channel even if it is faulted, 
    /// and it will unwrap exceptions so there wont be any 
    /// </summary>
    /// <typeparam name="T">The type of the interface.</typeparam>
    public abstract class DiscoProxy3<T> : ProxyBase<T>
        where T : class
    {



        private readonly Dictionary<string, string> _context;

        public ClientCredentials Credentials { get; set; }



        private T _client;
        protected T Client
        {
            get { return _client ?? (_client = CreateClient()); }
        }




        protected DiscoProxy3()
        {
            _context = new Dictionary<string, string>();
        }

        /// <summary>
        /// Adds to context.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="value">The value.</param>
        public void AddToContext(string name, string value)
        {
            if (WulkaContext.Current != null)
                WulkaContext.Current.Add(name, value);
            else
                _context.Add(name, value);
        }

        /// <summary>
        /// Gets the <see cref="System.String"/> with the specified name.
        /// </summary>
        /// <value></value>
        public string this[string name]
        {
            get
            {
                return WulkaContext.Current != null ? WulkaContext.Current[name] : _context[name];
            }
        }

        /// <summary>
        /// Removes from context.
        /// </summary>
        /// <param name="name">The name.</param>
        public void RemoveFromContext(string name)
        {
            if (WulkaContext.Current != null)
                WulkaContext.Current.Remove(name);
            else
                _context.Remove(name);
        }


        #region IAutoDiscoveringAgent Members
        /// <summary>
        /// Gets the type of the contract.
        /// </summary>
        /// <returns></returns>
        protected virtual string GetContractType()
        {
            return String.Format("{0}:{1}", GetContractNamespace(), typeof(T).Name);
        }

        protected virtual string GetContractNamespace()
        {
            return ServiceConst.Namespace;
        }


        /// <summary>
        /// Creates the specific client.
        /// </summary>
        /// <returns></returns>
        protected  T CreateClient()
        {
            try
            {
                DiscoCache discoC = DiscoCache.CreateDiscoCache();
                discoC.ContractType = GetContractType();
                var binding = discoC.GetBinding();
                var endpointAddress = discoC.GetEndPointAdress();
                return CreateClientInternal(binding,endpointAddress,
                    WulkaCredentials.Current);
            }
            catch (Exception e)
            {
                _logger.Error(e.GetCombinedMessages());
                if (e.InnerException != null)
                    throw e.InnerException;
                throw;
            }
        }

        private readonly Logger _logger = LogManager.GetLogger(String.Format("DiscoProxy3<{0}>", typeof(T).Name));

        /// <summary>
        /// Creates the client internal.
        /// </summary>
        /// <param name="binding">The binding.</param>
        /// <param name="endpointAddress">The endpoint address.</param>
        /// <param name="credentials">The credentials.</param>
        /// <returns></returns>
        protected virtual T CreateClientInternal(Binding binding, 
            EndpointAddress endpointAddress, 
            CredentialsBase credentials)
        {
            ProxyConnectionPool.EnableConnectionPool = false;
            return GetReusableFaultUnwrappingInstance(binding, endpointAddress, credentials);
        }

   





        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        public override void Dispose()                                                                                                                                                                                                                                                                                                                                                                  
        {
            CloseClient(Client);
            base.Dispose();
        }








        #endregion

    }

}
